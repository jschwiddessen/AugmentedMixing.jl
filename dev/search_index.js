var documenterSearchIndex = {"docs":
[{"location":"#AugmentedMixing","page":"Home","title":"AugmentedMixing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for AugmentedMixing.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#AugmentedMixing.AugmentedMixing","page":"Home","title":"AugmentedMixing.AugmentedMixing","text":"AugmentedMixing.jl - Implementation of the Augmented Mixing Method for large-scale SDPs\n\nThis package implements a Burer-Monteiro factorization-based algorithm for arbitrary semidefinite programs in which the factorization matrices are updated in a column-wise fashion. Users can call augmented_mixing, which solves an SDP specified by a struct SdpData and returns an approximate primal-dual solution together with a WarmStart object to work with extended precision.\n\nPublic API\n\naugmented_mixing - main routine called by user\nSdpData - struct to specify the SDP to be solved\nWarmStart - struct returned by augmented_mixing; can be used for doing a warm start\n\nWe refer to the preprint https://arxiv.org/abs/2507.20386 for implementation details and in-depth explanations of all parameters.\n\n\n\n\n\n","category":"module"},{"location":"#AugmentedMixing.SdpData","page":"Home","title":"AugmentedMixing.SdpData","text":"struct SdpData{\n    T<:AbstractFloat,\n    M<:Union{Matrix{T},SparseMatrixCSC{T,Int64}},\n    M2<:Union{Matrix{T},SparseMatrixCSC{T,Int64}},\n}\n\nUsed to specify an SDP that can be solved with augmented_mixing.\n\nAn SDP with q blocks reads:\n\nminimize < C_1 , X_1 > + ... + < C_q , X_q > subject to A_1(X_1) + ... + A_q(X_q) = (or >=) b and X_1, ... , X_q are symmetric, positive semidefinite matrices\n\nNotes\n\nAll provided matrices must be symmetric. All matrices and vectors must be either of type Matrix{T} or SparseMatrixCSC{T,Int64}.\n\nInequality constraints are supported. All affine constraints must be ordered such that all equality constraints appear first, followed by all inequality constraints. The argument index_ineq_start must be set to the index of the first inequality constraint. If there are no inequality constraints, then index_ineq_start must be set to length(b) + 1.\n\nThe constraint matrices of affine constraints can be specified in two ways:\n\nA vector of symmetric matrices (same length as b). For single-block SDPs, the corresponding container is A::Vector{M} and for multi-block SDPs, the container is As::Vector{Vector{M}}.\nA single big matrix in which each row contains the respective vectorized constraint matrix. For single-block SDPs, the corresponding container is A::M and for multi-block SDPs, the container is As_vec::Vector{M}.\n\nFor containers with two dimensions, the first dimension always identifies the block.\n\nConstructors\n\nGeneral constructors for multi-block SDPs:\n\nsdp = SdpData(As::Vector{Vector{M}}, b::Vector{T}, Cs::Vector{M2}, index_ineq_start::Int64)\nsdp = SdpData(As_vec::Vector{M}, b::Vector{T}, Cs::Vector{M2}, index_ineq_start::Int64)\n\nConstructors for single-block SDPs:\n\nsdp = SdpData(A::M, b::Vector{T}, C::M2, index_ineq_start::Int64)\nsdp = SdpData(A::Vector{M}, b::Vector{T}, C::M2, index_ineq_start::Int64)\n\nConverting to a different floating-point type (e.g. Float64 -> BigFloat): WARNING: Use with care! This cannot increase the precision of the SDP data itself.\n\nsdp = SdpData(sdp::SdpData{T,M,M2}, T_new::Type{<:AbstractFloat})\n\n\n\n\n\n","category":"type"},{"location":"#AugmentedMixing.WarmStart","page":"Home","title":"AugmentedMixing.WarmStart","text":"struct WarmStart{T<:AbstractFloat}\n    mu::T\n    Vs::Vector{Matrix{T}}\n    y::Vector{T}\n\nStruct to save a state snapshot for warm-starting augmented_mixing.\n\nmu: current penalty parameter  \nVs: block-wise Burer-Monteiro factorization matrices (for each SDP block b, X_b = V_b' * V_b)  \ny: dual multipliers for affine constraints (nonnegative for inequalities)\n\nTwo constructors are provided:\n\nWarmStart(mu, Vs, y) - not recommended to be used\nWarmStart(ws::WarmStart{T}, T_new::Type) - convert a struct WarmStart to another floating-point type (e.g. Float64 -> BigFloat)\n\nA struct WarmStart is returned by augmented_mixing and can be fed back via the warm_start keyword to continue a previous run or to refine a solution after promoting to extended precision.\n\n\n\n\n\n","category":"type"},{"location":"#AugmentedMixing.augmented_mixing-Union{Tuple{SdpData{T, M, M2}}, Tuple{M2}, Tuple{M}, Tuple{T}} where {T<:AbstractFloat, M<:Union{SparseArrays.SparseMatrixCSC{T, Int64}, Matrix{T}}, M2<:Union{SparseArrays.SparseMatrixCSC{T, Int64}, Matrix{T}}}","page":"Home","title":"AugmentedMixing.augmented_mixing","text":"Xs, y, Zs, status, ws = augmented_mixing(sdp::SdpData{T,M,M2};\n                 tol::T = T(1e-12),\n                 mu_start::T = T(sqrt(maximum(sdp.ns))),\n                 time_limit::Float64 = typemax(Float64),\n                 max_iters::Int = typemax(Int),\n                 iters_Z::Int = 50,\n                 scaling::Bool = true,\n                 shuffling::Bool = false,\n                 double_sweep::Bool = false,\n                 warm_start::Union{WarmStart,Nothing} = nothing,\n                 p::T = one(T),\n                 delta::T = T(1e-2),\n                 epsilon::T = T(1e-2),\n                 max_evals::Int = 1000,\n                 tau::T = T(1.03),\n                 rat_min::T = T(0.8),\n                 rat_max::T = T(1.2))\n\nSolve the SDP provided in sdp using the Augmented Mixing Method.\n\nArguments\n\nsdp: SDP problem data. See SdpData.\n\nOptional keyword arguments\n\ntol: stopping tolerance\nmu_start: initial value of penalty parameter\ntime_limit: maximum wall-clock time in seconds\nmax_iters: maximum number of outer iterations\niters_Z: frequency for computing psd projections\nscaling: whether automatic scaling is applied\nshuffling: whether column update order is randomized\ndouble_sweep: whether columns are updated in both forward and reverse order\nwarm_start: can be specified for triggering a warm start\np: dual step size\ndelta: relative tolerance for solving subproblems\nepsilon: absolute tolerance for solving subproblems\nmax_evals: maximum number of function and gradient evaluations per column update\ntau: factor for updating the penalty parameter\nrat_min: lower bound for ratio-based balancing of penalty parameter\nrat_max: upper bound for ratio-based balancing of penalty parameter\n\nReturn values\n\nXs::Vector{Matrix{T}}: primal matrices (symmetric and psd)\ny::Vector{T}: dual multipliers (nonnegative for inequalities)\nZs::Vector{Matrix{T}}: dual slack matrices (symmetric and psd)\nstatus::Symbol: one of :tol, :time, :iter (reason for termination)\nws::WarmStart{T}: struct to allow warm start from last iterate\n\nNotes\n\nWe refer to the preprint https://arxiv.org/abs/2507.20386 for implementation details and further explanations of all optional keyword arguments.\n\n\n\n\n\n","category":"method"}]
}
